<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>E.CO PG Run Data Collection Form - MPL</title>
  <link rel="stylesheet" href="styles.css" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/css/select2.min.css" rel="stylesheet" />
</head>
<body>

<div class="login-container" id="loginContainer">
  <h2>Login</h2>
  <form id="loginForm">
    <div class="input-group">
      <label for="username">Username:</label>
      <input type="text" id="username" name="username" required placeholder="Enter your username">
      <span class="error-message" id="username-error"></span>
    </div>

    <div class="input-group">
      <label for="password">Password:</label>
      <input type="password" id="password" name="password" required placeholder="Enter your password">
      <span class="error-message" id="password-error"></span>
    </div>

    <button type="submit">Login</button>

    <div class="login-message" id="login-status"></div>
  </form>
</div>

<div id="formContainer" style="display: none;">
  <div class="container">
    <h2>E.CO PG Run Data Collection Form-MPL</h2>
    <form id="pgForm" novalidate>
      <div class="card">
        <label for="ttNumber">TT Number:</label>
        <input type="text" id="ttNumber" name="ttNumber" />
        <span class="error-message" id="ttNumber-error"></span>

        <label for="operatorName">Operator Name:</label>
        <select id="operatorName" name="operatorName">
          <option value="" disabled selected>Select an operator</option>
          <option value="GP">GP</option>
          <option value="BL">BL</option>
          <option value="ROBI">ROBI</option>
        </select>
        <span class="error-message" id="operatorName-error"></span>

        <label for="siteDropdown">Select Site:</label>
        <select id="siteDropdown" name="site"></select>
        <span class="error-message" id="siteDropdown-error"></span>
      </div>

      <div class="card">
        <label for="pgOperatorDropdown">Select PG Operator Name:</label>
        <select id="pgOperatorDropdown" name="pgOperator"></select>
        <span class="error-message" id="pgOperatorDropdown-error"></span>

        <label for="teamLeaderDropdown">Select Team Leader Name:</label>
        <select id="teamLeaderDropdown" name="teamLeader"></select>
        <span class="error-message" id="teamLeaderDropdown-error"></span>
      </div>

      <div class="card">
        <label for="selectOption">Select Option:</label>
        <select id="selectOption" name="selectOption">
          <option value="" disabled selected>Select an option</option>
          <option value="Misscall TT">Misscall TT</option>
          <option value="PG Run">PG Run</option>
        </select>
        <span class="error-message" id="selectOption-error"></span>
      </div>

      <div id="misscallTTFields" style="display: none;">
        <div class="card">
          <label for="siteAttend">Site Attend:</label>
          <select id="siteAttend" name="siteAttend">
            <option value="" disabled selected>Select an option</option>
            <option value="YES">YES</option>
            <option value="NO">NO</option>
          </select>
          <span class="error-message" id="siteAttend-error"></span>
        </div>
        <div id="siteAttendDateTimeField" style="display: none;">
          <div class="card">
            <label for="siteAttendDateTime">Site Attend Date & Time:</label>
            <input type="datetime-local" id="siteAttendDateTime" name="siteAttendDateTime" />
            <span class="error-message" id="siteAttendDateTime-error"></span>
          </div>
        </div>
      </div>

      <div id="pgRunFields" style="display: none;">
        <div id="pgEventsContainer">
          </div>
        <button type="button" id="addEventBtn" class="add-button">Add Another Event</button>
      </div>

      <button type="submit">Submit</button>
      <div class="loading">Submitting...</div>
      <div class="success-message">Submission successful!</div>
    </form>
  </div>
</div>


<div class="footer-info">
  <p>Powered and Developed By<br>
    <strong>Rakibul Islam Ratul</strong><br>
    <small>Sr. Manager, Central Governance, Metal Plus Ltd.</small></p>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.min.js"></script>
<script>
  $(document).ready(function () {
    console.log("Document ready."); // Log document ready

    const MAX_EVENTS = 10; // Set the maximum number of events allowed
    let eventCount = 0; // Counter for dynamic events

    // Helper function to get current date/time inYYYY-MM-DDTHH:MM format
    function getCurrentDateTimeLocal() {
      const now = new Date();
      const year = now.getFullYear();
      const month = (now.getMonth() + 1).toString().padStart(2, '0');
      const day = now.getDate().toString().padStart(2, '0');
      const hours = now.getHours().toString().padStart(2, '0');
      const minutes = now.getMinutes().toString().padStart(2, '0');
      return `${year}-${month}-${day}T${hours}:${minutes}`;
    }

    // Helper function to parse date/time string into a Date object (should work with native datetime-local)
    function parseDateTime(datetimeStr) {
      if (!datetimeStr) {
        return null;
      }
      const date = new Date(datetimeStr);
      if (isNaN(date.getTime())) {
        return null;
      }
      return date;
    }

    // Helper function to display or clear error messages and apply invalid class
    function displayError(fieldId, message) {
      const errorSpan = $(`#${fieldId}-error`);
      const fieldElement = $(`#${fieldId}`);

      if (!fieldElement.length) {
        console.error(`Field element #${fieldId} not found.`);
        if (errorSpan.length) errorSpan.text('');
        return;
      }

      if (!errorSpan.length) {
        console.warn(`Error span not found for field: #${fieldId}-error. This field's errors will not be displayed visually, only invalid class applied.`);
        if (message) {
          fieldElement.addClass('is-invalid');
          // Special handling for Select2 fields
          if (fieldElement.hasClass('select2-hidden-accessible')) {
            fieldElement.next('.select2-container').find('.select2-selection--single').addClass('is-invalid');
          }
        } else {
          fieldElement.removeClass('is-invalid');
          if (fieldElement.hasClass('select2-hidden-accessible')) {
            fieldElement.next('.select2-container').find('.select2-selection--single').removeClass('is-invalid');
          }
        }
        return;
      }

      if (message) {
        errorSpan.text(message);
        fieldElement.addClass('is-invalid');
        if (fieldElement.hasClass('select2-hidden-accessible')) {
          fieldElement.next('.select2-container').find('.select2-selection--single').addClass('is-invalid');
        }
      } else {
        errorSpan.text('');
        fieldElement.removeClass('is-invalid');
        if (fieldElement.hasClass('select2-hidden-accessible')) {
          fieldElement.next('.select2-container').find('.select2-selection--single').removeClass('is-invalid');
        }
      }
    }

    // Validates a single field for being mandatory if visible
    function validateField(fieldId) {
      const fieldElement = $(`#${fieldId}`);
      // Only validate if the field or its closest card is visible
      if (fieldElement.is(':visible') || fieldElement.closest('.card').is(':visible') || fieldElement.closest('.event-card').is(':visible')) {
        const value = fieldElement.val();
        if (!value) {
          displayError(fieldId, 'This field is mandatory.');
          return false;
        } else {
          displayError(fieldId, '');
          return true;
        }
      } else {
        // If the field is not visible, clear any existing error and consider it valid in this context
        displayError(fieldId, '');
        return true;
      }
    }


    // --- Comprehensive Real-time Validation Function ---
    function validateAllFields() {
      console.log("Running comprehensive validation...");
      const selectOption = $('#selectOption').val();
      let formIsValid = true; // Assume valid until proven otherwise

      // 1. Validate core mandatory fields (TT Number, Operators, Site, Select Option)
      // Only validate if their card is visible (which they always are in this design)
      if (!validateField('ttNumber')) formIsValid = false;
      if (!validateField('operatorName')) formIsValid = false;
      if (!validateField('siteDropdown')) formIsValid = false;
      if (!validateField('pgOperatorDropdown')) formIsValid = false;
      if (!validateField('teamLeaderDropdown')) formIsValid = false;
      if (!validateField('selectOption')) formIsValid = false;

      // 2. Validate conditional fields based on Select Option
      if (selectOption === 'Misscall TT') {
        console.log("Validating Misscall TT fields...");
        // Site Attend is mandatory if Misscall TT is selected and section visible
        if (!validateField('siteAttend')) formIsValid = false;
        const siteAttend = $('#siteAttend').val();
        // Site Attend Date & Time is mandatory if Site Attend is YES and field is visible
        if (siteAttend === 'YES' && $('#siteAttendDateTime').is(':visible')) {
          const siteAttendDateTimeVal = $('#siteAttendDateTime').val();
          if (!siteAttendDateTimeVal) {
            displayError('siteAttendDateTime', 'Date & Time is mandatory when Site Attend is YES.');
            formIsValid = false;
          } else {
            const siteAttendDateTime = parseDateTime(siteAttendDateTimeVal);
            const now = new Date();
            if (!siteAttendDateTime || siteAttendDateTime > now) {
              displayError('siteAttendDateTime', 'Invalid or future date/time.');
              formIsValid = false;
            } else {
              displayError('siteAttendDateTime', '');
            }
          }
        } else {
          // If Site Attend is NOT YES or section is hidden, clear DateTime error
          displayError('siteAttendDateTime', '');
        }

        // Clear PG Run errors if switching away from Misscall TT
         $('#pgEventsContainer').children('.event-card').each(function() {
             const eventNumber = $(this).data('event-number');
             displayError(`pgStart${eventNumber}`, '');
             displayError(`pgStop${eventNumber}`, '');
         });


      } else if (selectOption === 'PG Run') {
        console.log("Validating PG Run fields...");
        const eventCards = $('#pgEventsContainer').children('.event-card');
        let previousEventStop = null; // To track the stop time of the previous *valid* event

        // Check if at least the first event exists and is filled if PG Run is selected
        if (eventCards.length === 0) {
             console.warn("PG Run selected but no event cards found for validation.");
             formIsValid = false; // At least one event is mandatory for PG Run
        } else {
            // Iterate over all dynamic event cards for validation
             eventCards.each(function(index) {
                 const eventNumber = index + 1; // Re-calculate event number based on index
                 const pgStartId = `pgStart${eventNumber}`;
                 const pgStopId = `pgStop${eventNumber}`;

                 const pgStartVal = $(`#${pgStartId}`).val();
                 const pgStopVal = $(`#${pgStopId}`).val();

                 const pgStart = parseDateTime(pgStartVal);
                 const pgStop = parseDateTime(pgStopVal);
                 const now = new Date();

                 let currentEventValid = true; // Flag for the current event pair's internal validity

                 // --- Validation Logic for Each Event ---

                 // For the 1st event, both Start and Stop are mandatory if PG Run is selected
                 if (eventNumber === 1) {
                      if (!pgStartVal) {
                           displayError(pgStartId, 'Mandatory for 1st event (PG Run).');
                           formIsValid = false;
                           currentEventValid = false;
                      } else {
                           displayError(pgStartId, ''); // Clear mandatory error if filled
                      }
                      if (!pgStopVal) {
                           displayError(pgStopId, 'Mandatory for 1st event (PG Run).');
                           formIsValid = false;
                           currentEventValid = false;
                      } else {
                           displayError(pgStopId, ''); // Clear mandatory error if filled
                      }

                      // If 1st event is filled, perform date/time validation
                      if (pgStartVal && pgStopVal) {
                           // Validate date formats
                           if (!pgStart) { displayError(pgStartId, 'Invalid format/value.'); currentEventValid = false; formIsValid = false; }
                           if (!pgStop) { displayError(pgStopId, 'Invalid format/value.'); currentEventValid = false; formIsValid = false; }

                           if (currentEventValid) { // Check currentEventValid after format check
                                // Validate Start < Stop
                                if (pgStop <= pgStart) {
                                     displayError(pgStopId, 'Must be after Start time.');
                                     formIsValid = false;
                                     currentEventValid = false;
                                } else {
                                     displayError(pgStopId, '');
                                }
                                // Validate not in future
                                if (pgStart > now) {
                                     displayError(pgStartId, 'Future date/time not allowed.');
                                     formIsValid = false;
                                     currentEventValid = false;
                                } else {
                                     displayError(pgStartId, '');
                                }
                                if (pgStop > now) {
                                     displayError(pgStopId, 'Future date/time not allowed.');
                                     formIsValid = false;
                                     currentEventValid = false;
                                } else {
                                     displayError(pgStopId, '');
                                }

                                // If 1st event is valid, set previousEventStop for the next event
                                if (currentEventValid) {
                                     previousEventStop = pgStop;
                                     console.log(`1st Event is valid. Setting previousEventStop for next event.`);
                                } else {
                                     previousEventStop = null; // Break sequence
                                     console.log(`1st Event has validation issues. Breaking sequence.`);
                                }
                           } else { // Invalid format in 1st event
                               formIsValid = false;
                               previousEventStop = null; // Break sequence
                                console.log(`1st Event format invalid. Breaking sequence.`);
                           }
                      } else { // 1st event is incomplete (caught above), break sequence
                           previousEventStop = null;
                           console.log(`1st Event is incomplete. Breaking sequence.`);
                      }

                 } else { // For subsequent events (2nd, 3rd, etc.)

                      // Case 1: Partially filled (INVALID - Mandatory if providing any time)
                      if ((pgStartVal && !pgStopVal) || (!pgStartVal && pgStopVal)) {
                           displayError(pgStartId, `Both times mandatory if providing any time for Event ${eventNumber}.`);
                           displayError(pgStopId, `Both times mandatory if providing any time for Event ${eventNumber}.`);
                           formIsValid = false;
                           currentEventValid = false;
                           previousEventStop = null; // Break sequence
                           console.log(`Event ${eventNumber} is partially filled, invalid.`);
                      }
                      // Case 2: Both fields have data (Proceed with detailed date/time validation)
                      else if (pgStartVal && pgStopVal) {
                           displayError(pgStartId, ''); // Clear partial mandatory error
                           displayError(pgStopId, '');

                           // Validate date formats
                           if (!pgStart) { displayError(pgStartId, 'Invalid format/value.'); currentEventValid = false; formIsValid = false; console.log(`Event ${eventNumber} Start has invalid format.`); }
                           if (!pgStop) { displayError(pgStopId, 'Invalid format/value.'); currentEventValid = false; formIsValid = false; console.log(`Event ${eventNumber} Stop has invalid format.`); }

                           // If formats are valid, perform date/time comparisons
                           if (currentEventValid) { // Check currentEventValid after format check
                                // Validate Start < Stop
                                if (pgStop <= pgStart) {
                                    displayError(pgStopId, 'Must be after Start time.');
                                    formIsValid = false;
                                    currentEventValid = false;
                                     console.log(`Event ${eventNumber} Stop is not after Start.`);
                                } else {
                                    displayError(pgStopId, ''); // Clear if valid
                                }

                                // Validate not in future
                                if (pgStart > now) {
                                    displayError(pgStartId, 'Future date/time not allowed.');
                                    formIsValid = false;
                                    currentEventValid = false;
                                     console.log(`Event ${eventNumber} Start is in the future.`);
                                } else {
                                    displayError(pgStartId, ''); // Clear if valid
                                }
                                if (pgStop > now) {
                                    displayError(pgStopId, 'Future date/time not allowed.');
                                    formIsValid = false;
                                    currentEventValid = false;
                                     console.log(`Event ${eventNumber} Stop is in the future.`);
                                } else {
                                    displayError(pgStopId, ''); // Clear if valid
                                }

                                // Validate Start time is after previous event's Stop time (if previous event exists and was valid)
                                if (previousEventStop && pgStart <= previousEventStop) {
                                    displayError(pgStartId, `Must be after Event ${eventNumber - 1}'s Stop time.`);
                                    formIsValid = false;
                                    currentEventValid = false;
                                     console.log(`Event ${eventNumber} Start is not after previous Stop.`);
                                } else if (previousEventStop) { // Only clear if a previous event existed and the current start is after it
                                     displayError(pgStartId, ''); // Clear if valid and previous existed
                                }

                                // If this event pair is valid internally and sequentially valid, update previousEventStop
                                if (currentEventValid) {
                                    previousEventStop = pgStop;
                                     console.log(`Event ${eventNumber} is valid. Setting previousEventStop for next event.`);
                                } else {
                                    // If the current event is invalid, break the sequence
                                    previousEventStop = null;
                                     console.log(`Event ${eventNumber} has validation issues. Breaking sequence.`);
                                }
                           } else { // If format is invalid
                               formIsValid = false;
                               previousEventStop = null; // Break sequence
                               console.log(`Event ${eventNumber} format is invalid.`);
                           }
                      }
                      // Case 3: Both fields are empty (VALID for optional skip, but breaks sequence)
                      else { // This 'else' now correctly follows the 'else if (pgStartVal && pgStopVal)'
                           displayError(pgStartId, ''); // Clear errors
                           displayError(pgStopId, '');
                           previousEventStop = null; // Break the sequence for the next event
                           currentEventValid = true; // It's valid in its empty state (for optional events)
                           console.log(`Event ${eventNumber} is empty and valid (optional skip).`);
                      }
                 }


             });
        } else {
             // If not PG Run, clear any PG Run errors
             $('#pgEventsContainer').children('.event-card').each(function() {
                 const eventNumber = $(this).data('event-number');
                 displayError(`pgStart${eventNumber}`, '');
                 displayError(`pgStop${eventNumber}`, '');
             });
        }


       // Manage "Add Event" button state based on the *last* event's validity and count
       const lastEventCard = $('#pgEventsContainer').children('.event-card').last();
       let lastEventCompleteAndValid = true; // Assume valid until proven otherwise for button state

       if (selectOption === 'PG Run' && lastEventCard.length > 0) {
           const lastEventNumber = eventCount;
           const lastPgStartId = `pgStart${lastEventNumber}`;
           const lastPgStopId = `pgStop${lastEventNumber}`;

           const lastPgStartVal = $(`#${lastPgStartId}`).val();
           const lastPgStopVal = $(`#${lastPgStopId}`).val();

           // An event is "complete and valid" for adding the next IF:
           // 1. It's completely empty (allowed for optional subsequent events) AND it's NOT the 1st event.
           // 2. OR, both fields are filled AND pass their internal and sequential validation checks.

           // Check if the last event has any validation errors currently displayed
            const lastStartHasError = $(`#${lastPgStartId}-error`).text() !== '';
            const lastStopHasError = $(`#${lastPgStopId}-error`).text() !== '';

            if (lastStartHasError || lastStopHasError) {
                lastEventCompleteAndValid = false; // Cannot add if last event has errors
                console.log("Last event has errors, disabling Add button.");
            } else if (!lastPgStartVal && !lastPgStopVal) {
                // If the last event is completely empty, it's valid to add the next ONLY IF it's NOT the 1st event
                 if (lastEventNumber > 1) {
                      lastEventCompleteAndValid = true;
                       console.log("Last event is empty (optional), enabling Add button.");
                 } else {
                      // 1st event is empty, which is invalid for PG Run
                      lastEventCompleteAndValid = false;
                       console.log("1st event is mandatory and empty, disabling Add button.");
                 }

            } else if (lastPgStartVal && lastPgStopVal) {
                 // If the last event is fully filled, check its validity based on date/time comparisons
                 const lastPgStart = parseDateTime(lastPgStartVal);
                 const lastPgStop = parseDateTime(lastPgStopVal);
                 const now = new Date();
                 let sequentialValid = true;

                 if (lastPgStart > now || lastPgStop > now || lastPgStop <= lastPgStart) {
                      sequentialValid = false; // Internal time errors (Start < Stop, not in future)
                 }

                 if (lastEventNumber > 1) {
                     // Check sequential validity against the previous *valid* stop time
                      let effectivePreviousEventStop = null;
                       $('#pgEventsContainer').children('.event-card').each(function(index) {
                           if (index < lastEventNumber - 1) { // Iterate through events before the last one
                                const currentCheckEventNumber = index + 1;
                                const checkPgStartVal = $(`#pgStart${currentCheckEventNumber}`).val();
                                const checkPgStopVal = $(`#pgStop${currentCheckEventNumber}`).val();
                                const checkPgStart = parseDateTime(checkPgStartVal);
                                const checkPgStop = parseDateTime(checkPgStopVal);
                                const checkNow = new Date();

                                // Consider a previous event valid for the sequence if it's fully filled and passes its own time checks
                                 if (checkPgStartVal && checkPgStopVal && checkPgStart && checkPgStop && checkPgStop > checkPgStart && checkPgStart <= checkNow && checkPgStop <= checkNow) {
                                      // If the current check event is fully valid, update the effective previous stop time
                                       effectivePreviousEventStop = checkPgStop;
                                 } else {
                                      // If a previous event is invalid or empty, the sequence is broken from this point onwards
                                       effectivePreviousEventStop = null; // Setting to null will make subsequent checks fail
                                 }
                           }
                       });


                       if (effectivePreviousEventStop && lastPgStart <= effectivePreviousEventStop) {
                            sequentialValid = false; // Sequential error
                       }
                 }

                 if (sequentialValid) {
                      lastEventCompleteAndValid = true;
                       console.log("Last event is filled and valid, enabling Add button.");
                 } else {
                      lastEventCompleteAndValid = false;
                       console.log("Last event is filled but has time errors, disabling Add button.");
                 }
            } else { // If the last event is partially filled (one field filled, other empty)
                 lastEventCompleteAndValid = false;
                 console.log("Last event is partially filled, disabling Add button.");
            }
       } else if (selectOption === 'PG Run' && lastEventCard.length === 0) {
            // If PG Run is selected but no events have been added yet, allow adding the first one
             lastEventCompleteAndValid = true;
              console.log("No events added yet, enabling Add button for the first event.");
       } else {
            // If not PG Run, the button isn't relevant, keep it enabled conceptually or hide it
             lastEventCompleteAndValid = true; // Button should be hidden anyway if section is hidden
       }


       // Disable the add button if the last event is not complete and valid, or if max events reached
       if (!lastEventCompleteAndValid || eventCount >= MAX_EVENTS) {
           $('#addEventBtn').prop('disabled', true);
            console.log("Add button disabled. Last event valid for add:", lastEventCompleteAndValid, "Event count:", eventCount);
       } else {
           $('#addEventBtn').prop('disabled', false);
            console.log("Add button enabled.");
       }


      console.log("Comprehensive validation complete. Form is valid:", formIsValid);
      return formIsValid; // Return overall form validity
    }


    // --- Dynamic Event Handling ---

    function addEventField(eventNumber) {
      if (eventCount >= MAX_EVENTS) {
        console.warn("Max events reached. Cannot add more.");
        $('#addEventBtn').hide(); // Ensure button is hidden if max reached
        return;
      }
       console.log(`Attempting to add Event ${eventNumber}.`);

      const nowFormatted = getCurrentDateTimeLocal();
      const eventCardHtml = `
            <div class="event-card" data-event-number="${eventNumber}">
              <h3>${eventNumber} Event</h3>
              <label for="pgStart${eventNumber}">PG Start Date & Time:</label>
               <input type="datetime-local" id="pgStart${eventNumber}" name="pgStart${eventNumber}" max="${nowFormatted}" />
               <span class="error-message" id="pgStart${eventNumber}-error"></span>
              <label for="pgStop${eventNumber}">PG Stop Date & Time:</label>
               <input type="datetime-local" id="pgStop${eventNumber}" name="pgStop${eventNumber}" max="${nowFormatted}" />
               <span class="error-message" id="pgStop${eventNumber}-error"></span>
               ${eventNumber > 1 ? '<button type="button" class="remove-button">Remove Event</button>' : ''}
            </div>
          `;
      $('#pgEventsContainer').append(eventCardHtml);
      eventCount++; // Increment the counter
       console.log(`Event ${eventNumber} HTML appended. New eventCount: ${eventCount}`);


      // Update the heading text (e.g., 1st Event, 2nd Event)
      const eventCard = $(`#pgEventsContainer .event-card:last`); // Select the newly added card
      const suffix = (eventNumber === 1) ? 'st' : (eventNumber === 2) ? 'nd' : (eventNumber === 3) ? 'rd' : 'th';
      eventCard.find('h3').text(`${eventNumber}${suffix} Event`);
       // Set the data attribute for the new card if it wasn't set in the HTML string
       eventCard.attr('data-event-number', eventNumber);


      // Attach event listeners for validation to the new inputs using event delegation
      // These listeners trigger the full validation process
      eventCard.find('input[type="datetime-local"]').on('change blur', function() {
           console.log(`Change/Blur event on newly added dynamic field: ${this.id}. Triggering full validation.`);
           validateAllFields(); // Trigger full validation on interaction
      });

       // The delegated listener for the remove button is already set up in initializeForm


      // Manage "Add Event" button visibility based on the updated event count
      if (eventCount >= MAX_EVENTS) {
        $('#addEventBtn').hide();
         console.log("Max events reached, hiding Add button.");
      } else {
        $('#addEventBtn').show(); // Ensure it's shown if under limit
         console.log("Add button shown.");
      }

       // Trigger validation after adding a field to update button state and initial errors
       validateAllFields();

        // Scroll to the newly added event (optional)
        $('html, body').animate({
           scrollTop: eventCard.offset().top - 100 // Adjust offset as needed
        }, 500);

      console.log(`Finished adding Event ${eventNumber}.`);
    }

    // Function to update event numbers and IDs after removal
    function updateEventNumbers() {
        console.log("Updating event numbers after removal...");
         // Re-attach delegated listener for remove buttons *before* re-rendering
         $('#pgEventsContainer').off('click', '.remove-button').on('click', '.remove-button', function() {
             console.log("Remove event button clicked (delegated).");
             $(this).closest('.event-card').remove(); // Remove the closest parent .event-card
             eventCount--; // Decrement the counter
             updateEventNumbers(); // Update event numbers and IDs, which also triggers validateAllFields
         });

         $('#pgEventsContainer').children('.event-card').each(function (index) {
             const currentCard = $(this);
            const newEventNumber = index + 1;
            const suffix = (newEventNumber === 1) ? 'st' : (newEventNumber === 2) ? 'nd' : (newEventNumber === 3) ? 'rd' : 'th';
            currentCard.find('h3').text(`${newEventNumber}${suffix} Event`);
            currentCard.attr('data-event-number', newEventNumber); // Update data attribute

            // Update input and span IDs and names
            currentCard.find('input[type="datetime-local"]').each(function () {
                const oldId = $(this).attr('id');
                const newId = oldId.replace(/\d+$/, newEventNumber);
                $(this).attr('id', newId).attr('name', newId);
                 // Update the corresponding error span ID
                $(`#${oldId}-error`).attr('id', `${newId}-error`);
            });

             // Manage the remove button for the current card
             const removeButton = currentCard.find('.remove-button');
             if (newEventNumber === 1) {
                  // Remove the button if it's the first event
                 if (removeButton.length) {
                      removeButton.remove();
                       console.log("Removed remove button from 1st event after renumbering.");
                 }
             } else {
                  // Add the button if it's not the first event and doesn't have one
                   // Check if a remove button *doesn't* exist before adding to prevent duplicates
                if (!removeButton.length) {
                     currentCard.append('<button type="button" class="remove-button">Remove Event</button>');
                      console.log(`Added remove button to Event ${newEventNumber}.`);
                     // The delegated listener handles the click event for this new button
                 }
             }
        });

       eventCount = $('#pgEventsContainer').children('.event-card').length; // Recalculate eventCount
        console.log("Event numbers and IDs updated. Recalculated eventCount:", eventCount);

       // Manage "Add Event" button visibility and disabled state after renumbering
       if (eventCount < MAX_EVENTS) {
           $('#addEventBtn').show();
           console.log("Add button shown after renumbering.");
       } else {
            $('#addEventBtn').hide();
             console.log("Add button hidden after renumbering (max events reached).");
       }

        // After renumbering and managing the button, re-validate to update states
       validateAllFields();
       console.log("Validation triggered after renumbering.");
    }


    // --- Function to fetch and populate dropdowns from Google Sheet via Proxy ---
    async function fetchAndPopulateDropdown(dropdownId, sheetName, columnName) {
        console.log(`Attempting to fetch and populate dropdown #${dropdownId} from sheet "${sheetName}" column "${columnName}"`);
        const dropdown = document.getElementById(dropdownId);
        if (!dropdown) {
            console.error(`Dropdown element #${dropdownId} not found.`);
            return;
        }

        // Clear existing options before populating
        $(dropdown).empty();
        // Add a default blank option for required fields with select2 allowClear
        $(dropdown).append('<option value=""></option>');

        try {
            const response = await fetch('/.netlify/functions/proxy', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    type: 'getDropdownData',
                    sheet: sheetName,
                    column: columnName
                })
            });

            console.log(`Dropdown data fetch response status for ${sheetName}/${columnName}: ${response.status}`);

            if (!response.ok) {
                 const errorText = await response.text();
                 console.error(`HTTP error fetching dropdown data for ${sheetName}/${columnName}: Status ${response.status}, Body: ${errorText}`);
                 throw new Error(`Failed to fetch data for ${sheetName}/${columnName}. Status: ${response.status}`);
            }

            const data = await response.json();
            console.log(`Data received for #${dropdownId}:`, data);

            if (data && Array.isArray(data.data)) {
                 if (data.data.length === 0) {
                      console.warn(`No data received for dropdown #${dropdownId}. Sheet "${sheetName}", column "${columnName}" might be empty or not found.`);
                 }
                data.data.forEach(item => {
                    if (item) {
                        const option = document.createElement('option');
                        option.value = item;
                        option.textContent = item;
                        dropdown.appendChild(option);
                    }
                });
                console.log(`Options added to #${dropdownId}.`);
            } else {
                console.error(`Invalid data format received for #${dropdownId}. Expected an object with an array 'data'. Received:`, data);
                throw new Error('Invalid data format received from server for dropdowns.');
            }

        } catch (error) {
            console.error(`Error fetching or populating dropdown data for #${dropdownId}:`, error);
            alert(`Failed to load data for dropdown "${dropdownId}". Please ensure the Google Sheet, sheet names, and column names are correct, and the Apps Script and proxy are configured to handle data requests. Error: ${error.message}`);
        } finally {
             if ($(dropdown).hasClass('select2-hidden-accessible')) {
                  $(dropdown).val(null).trigger('change.select2');
                  console.log(`Select2 triggered for #${dropdownId} after population attempt.`);
             } else {
                  console.warn(`Select2 not initialized on #${dropdownId}. Cannot trigger change.select2`);
             }
        }
    }


    // --- Function to Initialize the Form Features (Comprehensive Setup) ---
    // This function is called AFTER successful login
    function initializeForm() {
        console.log("Initializing form features...");

        // Initialize Select2 on form dropdowns
        $('#operatorName, #selectOption, #siteAttend, #siteDropdown, #pgOperatorDropdown, #teamLeaderDropdown').each(function() {
             if (!$(this).hasClass('select2-hidden-accessible')) {
                 $(this).select2({
                      placeholder: 'Select...',
                      allowClear: true,
                      dropdownParent: $('#formContainer')[0] // Ensure dropdown stays within form area
                 });
                  console.log(`Select2 initialized on #${this.id}`);
             }
         });
        console.log("Select2 initialization process completed.");

        // Set max date for native datetime-local inputs to prevent future selection
        const nowFormatted = getCurrentDateTimeLocal();
        $('input[type="datetime-local"]').attr('max', nowFormatted);
        console.log(`Set max date/time for datetime-local inputs to: ${nowFormatted}`);

        // --- Populate dropdowns after login ---
        fetchAndPopulateDropdown('siteDropdown', 'Sites', 'Site_Code');
        fetchAndPopulateDropdown('pgOperatorDropdown', 'Employees', 'Employee_Code');
        fetchAndPopdown('teamLeaderDropdown', 'Employees', 'Employee_Code');
        console.log("Dropdown data population process initiated after form initialization.");


        // --- Event Listeners for Real-time Validation and Conditional Logic ---

        // Listener for text input (TT Number) on blur
        $('#ttNumber').on('blur', function() {
            console.log("TT Number blur event fired. Triggering full validation.");
             // Only validate this field specifically if its container is visible, then run full validation
            if ($(this).closest('.card').is(':visible')) {
               validateField('ttNumber');
            } else {
                 displayError('ttNumber', '');
            }
            validateAllFields(); // Trigger full validation
         });

         // Listeners for Select2 dropdowns on change
         $('#operatorName, #siteDropdown, #pgOperatorDropdown, #teamLeaderDropdown, #selectOption, #siteAttend').on('change', function() {
              const fieldId = $(this).attr('id');
               console.log(`Change event fired on #${fieldId}. Triggering full validation.`);

              // Special handling for selectOption and siteAttend to manage section visibility *before* validation
              if (fieldId === 'selectOption') {
                   console.log("selectOption changed. Managing conditional sections.");
                    if ($(this).val() === 'Misscall TT') {
                        $('#misscallTTFields').show();
                        $('#pgRunFields').hide();
                         // Clear and reset PG Run fields/errors when hiding
                         $('#pgEventsContainer').empty();
                         eventCount = 0;
                         $('#addEventBtn').hide();
                         $('input[type="datetime-local"]', '#pgRunFields').val('');
                         $('select', '#pgRunFields').val(null).trigger('change.select2');

                    } else if ($(this).val() === 'PG Run') {
                        $('#misscallTTFields').hide();
                        $('#pgRunFields').show();
                         // Clear and reset Misscall TT fields/errors when hiding
                         $('select', '#misscallTTFields').val(null).trigger('change.select2');
                         $('input[type="datetime-local"]', '#misscallTTFields').val('');
                         $('#siteAttendDateTimeField').hide();

                         // Add the initial 1st event field if PG Run is selected and none exist
                         if (eventCount === 0) {
                             addEventField(1); // addEventField also triggers validation and button state
                         }
                         // Manage initial Add Event button visibility
                         if (eventCount < MAX_EVENTS) {
                             $('#addEventBtn').show();
                         } else {
                             $('#addEventBtn').hide();
                         }

                    } else { // If no option is selected
                        console.log("selectOption cleared. Hiding all conditional sections.");
                        $('#misscallTTFields').hide();
                        $('#pgRunFields').hide();
                         // Clear all conditional fields and errors
                         $('#pgEventsContainer').empty();
                         eventCount = 0;
                         $('#addEventBtn').hide();
                         $('select', '#misscallTTFields, #pgRunFields').val(null).trigger('change.select2');
                         $('input[type="datetime-local']', '#misscallTTFields, #pgRunFields').val('');
                         $('#siteAttendDateTimeField').hide();
                    }
              } else if (fieldId === 'siteAttend') {
                   console.log("siteAttend changed. Managing Site Attend DateTime field.");
                   if ($(this).val() === 'YES') {
                       $('#siteAttendDateTimeField').show();
                       // Re-set max date/time when shown
                        const nowFormatted = getCurrentDateTimeLocal();
                       $('#siteAttendDateTime').attr('max', nowFormatted);
                   } else {
                       $('#siteAttendDateTimeField').hide();
                       $('#siteAttendDateTime').val(''); // Clear native input
                   }
              }

              // Validate the changed field specifically if visible, then run full validation
              if ($(this).closest('.card').is(':visible') || $(this).closest('.event-card').is(':visible')) {
                 validateField(fieldId);
              } else {
                   displayError(fieldId, ''); // Clear error if hidden
              }
              validateAllFields(); // Trigger full validation after handling visibility
         });

        // Listeners for native datetime-local inputs (Site Attend, dynamic PG Events) on change and blur
        // Using delegation for dynamic PG Event fields
        $('#siteAttendDateTime, #pgEventsContainer').on('change blur', 'input[type="datetime-local"]', function() {
            console.log(`Change/Blur event on date/time field: ${this.id}. Triggering full validation.`);
             // Validate the changed field specifically if visible, then run full validation
             if ($(this).closest('.card').is(':visible') || $(this).closest('.event-card').is(':visible')) {
                // No specific validateField for datetime-local needed, validateAllFields handles its logic
             } else {
                 displayError($(this).attr('id'), ''); // Clear error if hidden
             }
             validateAllFields(); // Trigger full validation
        });


        // --- Add Event Button Listener ---
        $('#addEventBtn').on('click', function () {
            console.log("Add Event button clicked.");
             // The button's disabled state (managed by validateAllFields) prevents invalid clicks.
             // If click happens, assume validation passed (or was already handled).
             if (!$(this).is(':disabled')) {
                 addEventField(eventCount + 1); // addEventField also triggers validation
             } else {
                 // If the button is somehow clicked when disabled (e.g., rapidly clicking),
                 // provide feedback. The primary control is the disabled state.
                 alert("Please complete the current event before adding a new one.");
                  console.warn("Add Event button clicked while disabled.");
             }
        });

        // --- Delegated listener for Remove Event buttons ---
         // Attaches *once* to the pgEventsContainer for all current and future remove buttons
        $('#pgEventsContainer').on('click', '.remove-button', function () {
            console.log("Remove event button clicked (delegated).");
            $(this).closest('.event-card').remove(); // Remove the closest parent .event-card
            eventCount--; // Decrement the counter
            updateEventNumbers(); // Update event numbers and IDs, which also triggers validateAllFields
        });


       // --- Form Submission Handler ---
       $('#pgForm').submit(function (event) {
         event.preventDefault();
          console.log("Form submission started.");

          // Perform final comprehensive validation before attempting submission
          if (!validateAllFields()) { // validateAllFields handles all required and conditional checks
             $('.loading').hide(); // Ensure loading is hidden
             alert('Please fix the errors in the form before submitting.');
             console.log("Form validation failed before submit.");
             return; // Prevent submission if validation fails
          }
          console.log("Form validation passed. Preparing data for submission.");


          // Collect data dynamically, including all PG Run events
          const jsonData = {};

          // Collect standard fields by their IDs
          jsonData['ttNumber'] = $('#ttNumber').val() || '';
          jsonData['operatorName'] = $('#operatorName').val() || '';
          jsonData['site'] = $('#siteDropdown').val() || ''; // Get value from #siteDropdown
          jsonData['pgOperator'] = $('#pgOperatorDropdown').val() || ''; // Get value from #pgOperatorDropdown
          jsonData['teamLeader'] = $('#teamLeaderDropdown').val() || ''; // Get value from #teamLeaderDropdown
          jsonData['selectOption'] = $('#selectOption').val() || '';
          jsonData['siteAttend'] = $('#siteAttend').val() || '';
          jsonData['siteAttendDateTime'] = $('#siteAttendDateTime').val() || '';

           // Collect PG Run events dynamically if the section is visible and option is PG Run
           if (jsonData['selectOption'] === 'PG Run' && $('#pgRunFields').is(':visible')) {
               jsonData.pgEvents = []; // Initialize an array to hold PG events
                $('#pgEventsContainer').children('.event-card').each(function() {
                    const eventNumber = $(this).data('event-number'); // Get the event number
                    const pgStartVal = $(`#pgStart${eventNumber}`).val();
                    const pgStopVal = $(`#pgStop${eventNumber}`).val();

                    // Only include the event in the submitted data if both start and stop times are filled
                    // Validation already ensures this if PG Run is selected and events are present.
                    if (pgStartVal && pgStopVal) {
                        jsonData.pgEvents.push({
                            eventNumber: eventNumber,
                            start: pgStartVal,
                            stop: pgStopVal
                        });
                    }
                });
               console.log("Collected PG Events:", jsonData.pgEvents);

                // Final check: if PG Run is selected, there must be at least one valid event collected
                // This is covered by validateAllFields, but adding here for clarity in data collection step.
                if (jsonData.pgEvents.length === 0) {
                     console.error("PG Run selected but no valid events collected for submission. This should have been caught by validation.");
                     // Alert user again, although validation should prevent this
                     alert("PG Run is selected, but no valid event times were entered.");
                     $('.loading').hide(); // Ensure loading is hidden
                     return; // Stop submission
                }

                 // If PG Run is selected, and events are collected, delete the fixed keys from jsonData
                 // as they are replaced by the pgEvents array.
                 delete jsonData.pgStart1;
                 delete jsonData.pgStop1;
                 delete jsonData.pgStart2;
                 delete jsonData.pgStop2;
                 delete jsonData.pgStart3;
                 delete jsonData.pgStop3;

           } else {
                // If not PG Run, ensure the pgEvents array is not sent
                 delete jsonData.pgEvents;
                 // Also delete the fixed PG Run keys if they somehow got populated
                  delete jsonData.pgStart1;
                  delete jsonData.pgStop1;
                  delete jsonData.pgStart2;
                  delete jsonData.pgStop2;
                  delete jsonData.pgStart3;
                  delete jsonData.pgStop3;
           }


         jsonData.timestamp = new Date().toISOString(); // Add timestamp

         console.log("Data being sent:", JSON.stringify(jsonData, null, 2));

         $('.loading').show(); // Show loading message

         // Send form data to Google Apps Script via proxy
         fetch('/.netlify/functions/proxy', {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify(jsonData) // Send the collected JSON data
         })
         .then(response => {
             console.log("Form Fetch Response Status:", response.status);
             console.log("Form Fetch Response OK:", response.ok);
             console.log("Form Fetch Response Headers:", Array.from(response.headers.entries()));

             if (!response.ok) {
                  // If response is not OK, read text and throw error
                 return response.text().then(text => {
                      console.error(`Form HTTP error! status: ${response.status}, body: ${text}`);
                      throw new Error(`Form HTTP error! status: ${response.status}, body: ${text}`);
                 });
             }

              // If response is OK, attempt to parse JSON
             const contentType = response.headers.get("content-type");
             if (contentType && (contentType.includes("application/json") || contentType.includes("text/plain"))) {
                  return response.text().then(text => {
                       try {
                           // If text is empty or null, treat as an empty but successful-status response
                          if (!text || text.trim() === '') {
                               console.warn("Received empty response body for form submission.");
                              return {}; // Return empty object if response is empty but status is OK
                          }
                           return JSON.parse(text); // Parse the JSON
                       } catch (jsonError) {
                          console.error('Failed to parse form response as JSON:', jsonError, 'Response text:', text);
                           // If parsing fails, throw an error
                          throw new Error('Failed to parse JSON response from server for form submission.');
                       }
                  });
             } else {
                  // Unexpected content type
                  return response.text().then(text => {
                       console.error('Received unexpected content type from server for form submission:', contentType, 'Response text:', text);
                       throw new Error('Received unexpected response from server for form submission. Check Apps Script logs.');
                  });
             }
         })
         .then(result => {
           $('.loading').hide(); // Hide loading message
           console.log("Form Response JSON Result:", result);

            // Check if result is a valid object and indicates success
           if (result && typeof result === 'object' && result.result === 'success') {
               $('.success-message').show(); // Show success message
               $('#pgForm')[0].reset(); // Reset the form

                // Reset Select2 dropdowns and trigger change to clear them visually and update validation
                // Use .val(null) and .trigger('change.select2') to reset and update visual
               $('#operatorName, #selectOption, #siteAttend').val(null).trigger('change.select2');
                // Corrected IDs for reset
               $('#siteDropdown, #pgOperatorDropdown, #teamLeaderDropdown').val(null).trigger('change.select2');
                // Manually update Select2 placeholder visual for searchable ones if needed
                $('.select2-selection__rendered').empty().append('<span class="select2-selection__placeholder">Select...</span>');


                // Clear native datetime-local inputs
                 $('input[type="datetime-local"]').val('');
                 console.log("Cleared native datetime-local inputs.");


               // Trigger change on conditional fields to hide/show sections and clear values/errors properly
                // Trigger change.select2 for selects
               $('#selectOption').val(null).trigger('change.select2'); // This will also trigger the logic to hide sections and clear their content/errors
               // No need to trigger siteAttend change separately if selectOption handles hiding its container


               // Clear all validation errors and invalid classes after successful submission
               $('.error-message').text(''); // Clear error message spans
               $('input, select').removeClass('is-invalid'); // Remove invalid class from inputs/selects
               $('.select2-container .select2-selection--single').removeClass('is-invalid'); // Remove invalid class from Select2 visuals

                // Clear and reset dynamic PG Run fields container
               $('#pgEventsContainer').empty();
               eventCount = 0; // Reset counter
               $('#addEventBtn').hide(); // Hide the add button initially


               // Hide success message after a few seconds
               setTimeout(() => { $('.success-message').hide(); }, 3000);

               // After resetting the form and clearing fields, re-trigger initial validation state
               // This ensures mandatory fields show errors immediately on the blank form.
                triggerInitialValidation(); // Call a dedicated function for this


           } else {
               // Handle application-specific errors returned from script or unexpected response
                console.error('Submission result was not successful:', result);
                // Provide a more informative alert message
               const errorMessage = (result && typeof result === 'object' && result.error) ? result.error : (result === null || result === undefined || Object.keys(result).length === 0 ? 'Received empty or null response from server.' : 'Unknown response format from server.');
               alert('Submission failed: ' + errorMessage + ' Check browser console and Apps Script logs.');
           }
         })
         .catch(error => {
           $('.loading').hide(); // Hide loading message
           // This catches any errors thrown in the .then chain (network errors, JSON parsing errors, errors we threw)
           alert('Submission failed: ' + error.message); // This is the alert message
           console.error('Fetch Error:', error); // Log the full error object to browser console
         });
       });
        console.log("Form submission handler set up.");


        // --- Function to trigger initial validation on form display ---
        function triggerInitialValidation() {
             console.log("Triggering initial validation.");
             // Trigger blur/change on initial required fields to show errors on load if empty
             $('#ttNumber').trigger('blur'); // Trigger blur for text input validation
             // Trigger change for Select2 inputs to ensure their validation runs
             $('#operatorName, #siteDropdown, #pgOperatorDropdown, #teamLeaderDropdown, #selectOption').trigger('change.select2');

             // Also trigger a full validation check initially
             validateAllFields();
              console.log("Initial validation triggered.");
        }

       // Call triggerInitialValidation once after the form is initialized and shown
       // This call was missing or misplaced in previous versions
       triggerInitialValidation();

        console.log("Form initialization complete."); // Log form init completion

    } // End of initializeForm function


    // --- Login Page JavaScript ---

    // Helper function to display or clear error messages for the login form
    function displayLoginError(fieldId, message) {
        const errorSpan = $(`#${fieldId}-error`); // Target the specific error span for the login input
        const fieldElement = $(`#${fieldId}`); // The login input element (username or password)
         const loginStatusDiv = $('#login-status'); // The general login message div

         // Ensure fieldElement exists
         if (!fieldElement.length) {
              console.error(`Login field element #${fieldId} not found.`);
             if (errorSpan.length) errorSpan.text('');
             return;
         }


        // Handle input specific errors (username-error, password-error)
        if (errorSpan.length) {
            if (message) {
                errorSpan.text(message);
                fieldElement.addClass('is-invalid'); // Use is-invalid class for login inputs
            } else {
                fieldElement.removeClass('is-invalid');
            }
        }

         // Handle general login status messages (#login-status)
         if (fieldId === 'login-status') {
             loginStatusDiv.text(message);
             if (message) {
                 // Apply 'error' or 'success' class based on the message content
                  if (message.includes('Invalid') || message.includes('failed') || message.includes('Error')) {
                       loginStatusDiv.addClass('error').removeClass('success');
                  } else {
                       loginStatusDiv.addClass('success').removeClass('error');
                  }
                  loginStatusDiv.show(); // Show the message div
             } else {
                  loginStatusDiv.text('').removeClass('success error').hide(); // Hide and clear
             }
         }
    }

    // Handle login form submission
    $('#loginForm').submit(function(event) {
      event.preventDefault(); // Prevent default form submission
       console.log("Login form submitted."); // Log login form submission

      // Clear previous errors and status messages
      displayLoginError('username', ''); // Clear username error
      displayLoginError('password', ''); // Clear password error
      displayLoginError('login-status', ''); // Clear general status message

      const username = $('#username').val().trim(); // Get and trim username input
      const password = $('#password').val().trim(); // Get and trim password input
      let formIsValid = true; // Basic client-side check for login form

      // Basic validation for empty fields
      if (!username) {
        displayLoginError('username', 'Username is required.');
        formIsValid = false;
      }
      if (!password) {
        displayLoginError('password', 'Password is required.');
        formIsValid = false;
      }

      // If basic client-side validation fails, stop here
      if (!formIsValid) {
         displayLoginError('login-status', 'Please enter username and password.');
         console.log("Login form validation failed client-side.");
        return;
      }

      // Show a loading indicator using the login status div
       displayLoginError('login-status', 'Logging in...'); // Use the status div for loading message
       console.log("Attempting to fetch login endpoint."); // Log fetch attempt

      // Send login request to Google Apps Script via proxy
      fetch('/.netlify/functions/proxy', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ login: true, username: username, password: password }) // Send login flag and credentials
      })
      .then(response => {
           console.log("Login Fetch received response."); // Log receipt of response
           // Always read the response body, even on non-OK statuses, to get potential error messages
          return response.text().then(text => {
               console.log("Login Fetch Raw Response Text:", text); // Log raw response text
               console.log("Login Fetch Response Status:", response.status); // Log response status
               console.log("Login Fetch Response OK:", response.ok); // Log response OK status
               console.log("Login Fetch Response Headers:", Array.from(response.headers.entries())); // Log response headers

               // Attempt to parse the response text as JSON
               let data = null;
               try {
                   // If the text is not empty or null, try to parse it as JSON
                   if (text && text.trim() !== '') {
                       data = JSON.parse(text);
                        console.log("Login Fetch Parsed Data:", data); // Log parsed JSON data
                   } else {
                       // If the text is empty, it might be an empty but successful-status response or an error with no body
                       console.error("Received empty or null response body for login.");
                       // If the status is OK but the body is empty, throw an error
                       if (response.ok) {
                           throw new Error('Received empty response body from server.');
                       } else { // If status is not OK and body is empty, throw a status error
                           throw new Error(`Server returned status ${response.status} with empty body.`);
                       }
                   }
               } catch (jsonError) {
                   // If JSON parsing fails, log the error and the response text
                   console.error('Failed to parse login response as JSON:', jsonError, 'Response text:', text);
                    // If parsing fails and the status was OK, it's an unexpected format issue
                   if (response.ok) {
                        throw new Error('Login failed: Invalid JSON response from server.');
                   } else { // If status was not OK, the status error is more relevant
                        throw new Error(`Server returned status ${response.status} and invalid response format.`);
                   }
               }

               // If the response was not OK (status outside 200-299 range), even if JSON parsed, propagate the error
               if (!response.ok) {
                   // Use the server-provided error message if available in the parsed data, otherwise use a generic message
                   const serverErrorMessage = (data && typeof data === 'object' && data.error) ? data.error : 'Server error occurred.';
                   // Include the status code in the error message
                   throw new Error(`Login failed: Status ${response.status} - ${serverErrorMessage}`);
               }

               // If response is OK and JSON is parsed successfully, return the data
               return data;
          });
      })
      .then(data => {
        console.log("Login Response Data:", data); // Log the final data object
        // Check if data is a valid object and explicitly check if the 'success' property is boolean true
        if (data && typeof data === 'object' && data.success === true) {
          displayLoginError('login-status', 'Login successful!'); // Show success message
          console.log("Login successful, showing form."); // Log successful login
          $('#loginContainer').hide(); // Hide the login page container
          $('#formContainer').show(); // Show the form page container
           initializeForm(); // Call the function to initialize all form features
          } else {
            // Handle login failure based on the server response (data.success is false or missing)
            const errorMessage = (data && typeof data === 'object' && data.error) ? data.error : 'Invalid username or password.';
            displayLoginError('login-status', errorMessage); // Show the login failure message
            console.log("Login failed:", errorMessage); // Log the failure reason
            $('#password').val(''); // Optionally clear the password field on failure
            $('#username, #password').removeClass('is-invalid'); // Remove invalid classes from login inputs
          }
      })
      .catch(error => {
        console.error('Login Fetch Error:', error); // Log any errors that occurred during the fetch process
        displayLoginError('login-status', 'Login failed: ' + error.message); // Show a user-friendly error message
         $('#username, #password').removeClass('is-invalid'); // Remove invalid classes from login inputs on fetch error
      });
    });

     // Optional: Clear errors on input focus for login fields
      $('#username, #password').on('focus', function() {
          displayLoginError($(this).attr('id'), ''); // Clear specific input error on focus
          displayLoginError('login-status', ''); // Clear general status message on focus
      });

    // --- Initial State on document ready ---
    // The login container is shown by default in HTML, form container is hidden.
    // The login form submission handler is attached here.
    // The form initialization is deferred until successful login.
     $('#formContainer').hide();
     $('#loginContainer').show();
      console.log("Initial display state set: login visible, form hidden.");


  }); // End of $(document).ready
</script>

</body>
</html>