<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>E.CO PG Run Data Collection Form - MPL</title>
  <link rel="stylesheet" href="styles.css" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/css/select2.min.css" rel="stylesheet" />
</head>
<body>

<div class="login-container" id="loginContainer">
  <h2>Login</h2>
  <form id="loginForm">
    <div class="input-group">
      <label for="username">Username:</label>
      <input type="text" id="username" name="username" required placeholder="Enter your username">
      <span class="error-message" id="username-error"></span>
    </div>

    <div class="input-group">
      <label for="password">Password:</label>
      <input type="password" id="password" name="password" required placeholder="Enter your password">
      <span class="error-message" id="password-error"></span>
    </div>

    <button type="submit">Login</button>

    <div class="login-message" id="login-status"></div>
  </form>
</div>

<div id="formContainer" style="display: none;">
  <div class="container">
    <h2>E.CO PG Run Data Collection Form-MPL</h2>
    <form id="pgForm" novalidate>
      <div class="card">
        <label for="ttNumber">TT Number:</label>
        <input type="text" id="ttNumber" name="ttNumber" />
        <span class="error-message" id="ttNumber-error"></span>

        <label for="operatorName">Operator Name:</label>
        <select id="operatorName" name="operatorName">
          <option value="" disabled selected>Select an operator</option>
          <option value="GP">GP</option>
          <option value="BL">BL</option>
          <option value="ROBI">ROBI</option>
        </select>
         <span class="error-message" id="operatorName-error"></span>

        <label for="siteDropdown">Select Site:</label>
        <select id="siteDropdown" name="site"></select>
        <span class="error-message" id="siteDropdown-error"></span>
      </div>

      <div class="card">
        <label for="pgOperatorDropdown">Select PG Operator Name:</label>
        <select id="pgOperatorDropdown" name="pgOperator"></select>
         <span class="error-message" id="pgOperatorDropdown-error"></span>

        <label for="teamLeaderDropdown">Select Team Leader Name:</label>
        <select id="teamLeaderDropdown" name="teamLeader"></select>
         <span class="error-message" id="teamLeaderDropdown-error"></span>
      </div>

      <div class="card">
        <label for="selectOption">Select Option:</label>
        <select id="selectOption" name="selectOption">
          <option value="" disabled selected>Select an option</option>
          <option value="Misscall TT">Misscall TT</option>
          <option value="PG Run">PG Run</option>
        </select>
        <span class="error-message" id="selectOption-error"></span>
      </div>

      <div id="misscallTTFields" style="display: none;">
        <div class="card">
          <label for="siteAttend">Site Attend:</label>
          <select id="siteAttend" name="siteAttend">
            <option value="" disabled selected>Select an option</option>
            <option value="YES">YES</option>
            <option value="NO">NO</option>
          </select>
           <span class="error-message" id="siteAttend-error"></span>
        </div>
        <div id="siteAttendDateTimeField" style="display: none;">
           <div class="card">
               <label for="siteAttendDateTime">Site Attend Date & Time:</label>
               <input type="datetime-local" id="siteAttendDateTime" name="siteAttendDateTime" />
               <span class="error-message" id="siteAttendDateTime-error"></span>
           </div>
        </div>
      </div>

      <div id="pgRunFields" style="display: none;">
        <div id="pgEventsContainer">
             </div>
        <button type="button" id="addEventBtn" class="add-button">Add Another Event</button>
      </div>

       <button type="submit">Submit</button>
        <div class="loading">Submitting...</div>
        <div class="success-message">Submission successful!</div>
    </form>
  </div>
  </div>


<div class="footer-info">
  <p>Powered and Developed By<br>
  <strong>Rakibul Islam Ratul</strong><br>
  <small>Sr. Manager, Central Governance, Metal Plus Ltd.</small></p>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.min.js"></script>
<script>
  $(document).ready(function () {
    console.log("Document ready.");

    const MAX_EVENTS = 10; // Set the maximum number of events allowed
    let eventCount = 0; // Counter for dynamic events
    let loggedInUsername = ''; // Variable to store the logged-in username

    // Helper function to get current date/time in YYYY-MM-DDTHH:MM format
    function getCurrentDateTimeLocal() {
        const now = new Date();
        const year = now.getFullYear();
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        return `${year}-${month}-${day}T${hours}:${minutes}`;
    }

    // Helper function to parse date/time string (should work with native datetime-local) into a Date object
    function parseDateTime(datetimeStr) {
        if (!datetimeStr) {
            console.log("parseDateTime (frontend): Received empty string, returning null.");
            return null;
        }
        const date = new Date(datetimeStr);
        if (isNaN(date.getTime())) {
            console.log("parseDateTime (frontend): Parsed date is invalid for string:", datetimeStr);
            return null;
        }
         // console.log("parseDateTime (frontend): Parsed", datetimeStr, "into", date); // Optional detailed log
        return date;
    }

    // Helper function to display or clear error messages and apply invalid class
    function displayError(fieldId, message) {
        const errorSpan = $(`#${fieldId}-error`);
        const fieldElement = $(`#${fieldId}`);

        if (!fieldElement.length) {
            console.error(`Field element #${fieldId} not found for displayError.`);
             if (errorSpan.length) errorSpan.text('');
            return;
        }

        // Apply/Remove is-invalid class
        if (message) {
            fieldElement.addClass('is-invalid');
             // Special handling for Select2 fields - add class to the visual selection element
            if (fieldElement.hasClass('select2-hidden-accessible')) {
              fieldElement.next('.select2-container').find('.select2-selection--single').addClass('is-invalid');
            }
        } else {
            fieldElement.removeClass('is-invalid');
             if (fieldElement.hasClass('select2-hidden-accessible')) {
              fieldElement.next('.select2-container').find('.select2-selection--single').removeClass('is-invalid');
            }
        }

         // Update error message span
        if (errorSpan.length) {
             errorSpan.text(message);
         } else {
             if (message) console.warn(`Error span not found for field: #${fieldId}-error. Cannot display text error.`);
         }
    }


    // --- Validation Functions (Client-Side) ---

    function validateField(fieldId) {
        console.log(`Validating field: ${fieldId}`);
        const value = $(`#${fieldId}`).val();
        if (!value || (Array.isArray(value) && value.length === 0)) { // Check for empty string or empty array
            displayError(fieldId, 'This field is mandatory.');
            return false;
        } else {
            displayError(fieldId, '');
            return true;
        }
    }

    function validateAllConditionalFields() {
        console.log("Validating all conditional fields...");
        const selectOption = $('#selectOption').val();
        let allValid = true;

        // Validate Misscall TT fields if visible
        if (selectOption === 'Misscall TT' && $('#misscallTTFields').is(':visible')) {
            if (!validateField('siteAttend')) allValid = false;
            const siteAttend = $('#siteAttend').val();
            if (siteAttend === 'YES' && $('#siteAttendDateTimeField').is(':visible')) {
                const siteAttendDateTimeVal = $('#siteAttendDateTime').val();
                if (!siteAttendDateTimeVal) {
                    displayError('siteAttendDateTime', 'Date & Time is mandatory when Site Attend is YES.');
                    allValid = false;
                } else {
                    const siteAttendDateTime = parseDateTime(siteAttendDateTimeVal);
                    const now = new Date();
                    // Check if date is valid and not in the future
                    if (!siteAttendDateTime || isNaN(siteAttendDateTime.getTime()) || siteAttendDateTime > now) {
                         displayError('siteAttendDateTime', 'Invalid or future date/time.');
                         allValid = false;
                    } else {
                        displayError('siteAttendDateTime', '');
                    }
                }
            } else {
                 displayError('siteAttendDateTime', ''); // Clear if not required
            }
        } else {
             // Clear Misscall TT errors if section is hidden
            displayError('siteAttend', '');
            displayError('siteAttendDateTime', '');
        }


        // Validate PG Run fields if visible
        if (selectOption === 'PG Run' && $('#pgRunFields').is(':visible')) {
             console.log("Validating PG Run fields...");
            const eventCards = $('#pgEventsContainer').children('.event-card');
            let previousEventStop = null; // To track the stop time of the previous valid event for sequential validation

            let anyPgEventFullyFilled = false; // Flag to check if at least one PG event has both start/stop data

            eventCards.each(function(index) {
                const eventNumber = $(this).data('event-number'); // Get the dynamic event number
                const pgStartId = `pgStart${eventNumber}`;
                const pgStopId = `pgStop${eventNumber}`;

                const pgStartVal = $(`#${pgStartId}`).val();
                const pgStopVal = $(`#${pgStopId}`).val();

                const pgStart = parseDateTime(pgStartVal);
                const pgStop = parseDateTime(pgStopVal);
                const now = new Date();

                let currentEventValid = true; // Track validation for this specific event card

                // If either field has data, BOTH are mandatory for that event card
                if (pgStartVal || pgStopVal) {
                     if (pgStartVal && pgStopVal) {
                         anyPgEventFullyFilled = true; // Mark that at least one event is being fully used
                     }
                     console.log(`Validating Event ${eventNumber}: Start=${pgStartVal}, Stop=${pgStopVal}`);
                    if (!pgStartVal) {
                        displayError(pgStartId, 'Mandatory if providing Stop time.');
                        allValid = false;
                        currentEventValid = false;
                    } else {
                         // Clear specific error if value exists (and it was set to mandatory message)
                         if ($(`#${pgStartId}-error`).text() === 'Mandatory if providing Stop time.') displayError(pgStartId, '');
                    }
                    if (!pgStopVal) {
                        displayError(pgStopId, 'Mandatory if providing Start time.');
                        allValid = false;
                        currentEventValid = false;
                    } else {
                         // Clear specific error if value exists (and it was set to mandatory message)
                         if ($(`#${pgStopId}-error`).text() === 'Mandatory if providing Start time.') displayError(pgStopId, '');
                    }

                    // If both fields have data AND parsed into valid dates, perform date/time comparisons
                    if (pgStart && pgStop && !isNaN(pgStart.getTime()) && !isNaN(pgStop.getTime())) {
                         // Validate Start < Stop
                         if (pgStop <= pgStart) {
                             displayError(pgStopId, 'Must be after Start time.');
                             allValid = false;
                             currentEventValid = false;
                         } else {
                              // Clear if the specific error is present
                             if ($(`#${pgStopId}-error`).text().includes('after Start time')) displayError(pgStopId, '');
                         }

                         // Validate not in future
                         if (pgStart > now) {
                             displayError(pgStartId, 'Future date/time not allowed.');
                             allValid = false;
                             currentEventValid = false;
                         } else {
                              // Clear if the specific error is present
                             if ($(`#${pgStartId}-error`).text().includes('Future date/time')) displayError(pgStartId, '');
                         }
                         if (pgStop > now) {
                              displayError(pgStopId, 'Future date/time not allowed.');
                              allValid = false;
                              currentEventValid = false;
                         } else {
                              // Clear if the specific error is present
                             if ($(`#${pgStopId}-error`).text().includes('Future date/time')) displayError(pgStopId, '');
                         }


                         // Validate Start time is after previous event's Stop time (if previous valid event exists)
                         if (previousEventStop && pgStart <= previousEventStop) {
                             displayError(pgStartId, `Must be after Event ${eventNumber - 1}'s Stop time.`);
                             allValid = false;
                             currentEventValid = false;
                         } else {
                             // Clear if the specific error is present
                             const previousEventError = `Must be after Event ${eventNumber - 1}'s Stop time.`;
                             if ($(`#${pgStartId}-error`).text() === previousEventError) displayError(pgStartId, '');
                         }

                        // If this event pair is valid and sequentially valid, update previousEventStop for the next iteration
                         if (currentEventValid) {
                             previousEventStop = pgStop;
                              console.log(`Event ${eventNumber} is valid so far. Setting previousEventStop for next check.`);
                         } else {
                              console.log(`Event ${eventNumber} has validation issues. Breaking sequential check.`);
                              // If the current event is invalid, break the sequence for subsequent validations
                              previousEventStop = null;
                         }

                    } else if (pgStartVal || pgStopVal) { // If one field has data but parsing failed
                         console.log(`Event ${eventNumber} has data but parsing failed. Start=${pgStartVal}, Stop=${pgStopVal}`);
                         if (!pgStart && pgStartVal) { // Check if value exists but parsing failed
                             displayError(pgStartId, 'Invalid date/time format.');
                             allValid = false; currentEventValid = false;
                         }
                         if (!pgStop && pgStopVal) { // Check if value exists but parsing failed
                             displayError(pgStopId, 'Invalid date/time format.');
                             allValid = false; currentEventValid = false;
                         }
                         previousEventStop = null; // Break sequence on parsing error
                    } // If both fields are empty (handled below)


                } else { // If neither field has data for this event card
                     displayError(pgStartId, '');
                     displayError(pgStopId, '');
                    console.log(`Event ${eventNumber} fields are empty.`);
                     // If an event is completely empty, it breaks the sequence for the next event
                     previousEventStop = null;
                }
            });

            // After checking all event cards, ensure at least one event had *both* start and stop times filled,
            // IF PG Run is selected. If PG Run is selected and no event card is fully filled, it's an error.
            if (selectOption === 'PG Run' && !anyPgEventFullyFilled && eventCards.length > 0) {
                 // Target the first event card to show the mandatory message
                 const firstEventCard = $('#pgEventsContainer').children('.event-card').first();
                 if (firstEventCard.length > 0) {
                     const firstStartId = firstEventCard.find('input[type="datetime-local"][name^="pgStart"]').attr('id');
                     const firstStopId = firstEventCard.find('input[type="datetime-local"][name^="pgStop"]').attr('id');
                      displayError(firstStartId, 'At least one event must have both times filled for PG Run.');
                       displayError(firstStopId, 'At least one event must have both times filled for PG Run.');
                       allValid = false;
                       console.log("PG Run selected but no event is fully filled.");
                 } else {
                      // This case should ideally not happen if addEventField(1) runs.
                      console.warn("PG Run selected but no event cards found.");
                       // You might decide this state should prevent submission.
                       // The server-side check handles this too.
                 }
            } else if (selectOption === 'PG Run' && eventCards.length === 0) {
                 // This case should ideally not happen if addEventField(1) is called on selectOption change.
                 console.warn("PG Run selected but no event cards found. This might be a setup issue.");
                 // Decide if having 0 events when PG Run is selected should block submission.
                 // The server-side check added previously handles this explicitly.
            }


        } else {
             // Clear PG Run errors if section is hidden
             $('#pgEventsContainer').children('.event-card').each(function() {
                 const eventNumber = $(this).data('event-number');
                 displayError(`pgStart${eventNumber}`, '');
                 displayError(`pgStop${eventNumber}`, '');
             });
        }


        console.log("Overall client-side conditional validation result:", allValid);
        return allValid;
    }


     // --- Dynamic Event Handling ---

     function addEventField(eventNumber) {
         if (eventCount >= MAX_EVENTS) {
             alert(`You can add a maximum of ${MAX_EVENTS} events.`);
             return;
         }

         const nowFormatted = getCurrentDateTimeLocal();
         const suffix = (eventNumber === 1) ? 'st' : (eventNumber === 2) ? 'nd' : (eventNumber === 3) ? 'rd' : 'th';

         const eventCardHtml = `
            <div class="event-card" data-event-number="${eventNumber}">
              <h3>${eventNumber}${suffix} Event</h3>
              <label for="pgStart${eventNumber}">PG Start Date & Time:</label>
               <input type="datetime-local" id="pgStart${eventNumber}" name="pgStart${eventNumber}" max="${nowFormatted}" />
               <span class="error-message" id="pgStart${eventNumber}-error"></span>
              <label for="pgStop${eventNumber}">PG Stop Date & Time:</label>
               <input type="datetime-local" id="pgStop${eventNumber}" name="pgStop${eventNumber}" max="${nowFormatted}" />
               <span class="error-message" id="pgStop${eventNumber}-error"></span>
               ${eventNumber > 1 ? '<button type="button" class="remove-button">Remove Event</button>' : ''}
            </div>
          `;
         $('#pgEventsContainer').append(eventCardHtml);
         eventCount++; // Increment the counter


         // Attach event listeners for validation to the new inputs using event delegation
          $('#pgEventsContainer').on('change blur', `#pgStart${eventNumber}, #pgStop${eventNumber}`, function() {
               validateAllConditionalFields(); // Re-validate all PG events including sequential checks
          });


         // Attach listener for the remove button using delegation on the container
         if (eventNumber > 1) {
              // Attach the listener to the container, filtering for the remove button of the specific event number
              $('#pgEventsContainer').one('click', `[data-event-number="${eventNumber}"] .remove-button`, function() {
                  $(this).closest('.event-card').remove();
                  eventCount--; // Decrement the counter
                  updateEventNumbers(); // Update headings and IDs after removal
                   validateAllConditionalFields(); // Re-validate after removal
                   // Manage "Add Event" button visibility after removal
                  if (eventCount < MAX_EVENTS) {
                      $('#addEventBtn').show();
                  }
              });
         }

         // Manage "Add Event" button visibility
         if (eventCount >= MAX_EVENTS) {
             $('#addEventBtn').hide();
         } else {
             $('#addEventBtn').show(); // Ensure it's shown if under limit
         }
          console.log(`Added Event ${eventNumber}. Total events: ${eventCount}`);
     }

     // Function to update event numbers and IDs after removal
     function updateEventNumbers() {
          $('#pgEventsContainer').children('.event-card').each(function(index) {
              const oldEventNumber = $(this).data('event-number'); // Get the old number
              const newEventNumber = index + 1;
              const suffix = (newEventNumber === 1) ? 'st' : (newEventNumber === 2) ? 'nd' : (newEventNumber === 3) ? 'rd' : 'th';
              $(this).find('h3').text(`${newEventNumber}${suffix} Event`);

               // Update input and span IDs and names
              $(this).find('input[type="datetime-local"]').each(function() {
                  const oldId = $(this).attr('id'); // e.g., pgStart3
                  const newIdPrefix = oldId.replace(/\d+$/, ''); // e.g., pgStart
                  const newId = newIdPrefix + newEventNumber; // e.g., pgStart2

                   // Re-attach change/blur listeners to the *new* ID if not using delegation
                   // If using delegation (as implemented above), this step is not strictly needed for validation,
                   // but useful for updating the ID.
                   // If you were removing and re-adding listeners, you'd do it here.
                   // $(`#${oldId}`).off('change blur', validateAllConditionalFields); // Remove old listener
                   $(this).attr('id', newId).attr('name', newId);
                   // $(`#${newId}`).on('change blur', validateAllConditionalFields); // Add new listener (if not using delegation)

                   // Update the corresponding error span ID
                   const oldErrorSpan = $(`#${oldId}-error`);
                   if (oldErrorSpan.length) {
                        oldErrorSpan.attr('id', `${newId}-error`);
                   } else {
                         // If the error span didn't exist, log a warning
                         console.warn(`Error span #${oldId}-error not found during renumbering.`);
                   }
              });

              // Update the remove button if it exists and remove from the first event
              const removeButton = $(this).find('.remove-button');
              if (removeButton.length) {
                  if (newEventNumber === 1) {
                      // Remove button from the first event
                      removeButton.remove();
                       // Need to remove the delegated listener for this specific old button if it was attached uniquely
                  } else {
                       // If the event number is > 1 and the button exists, ensure its delegated listener is correctly attached (should be from addEventField)
                  }
              } else {
                   // If this card didn't have a remove button but now should (e.g., it was event 1, now event 2)
                   if (newEventNumber > 1) { // Check if a remove button *should* exist for this new number
                        $(this).append('<button type="button" class="remove-button">Remove Event</button>');
                         // Attach listener for the newly added remove button using delegation
                         // This listener is attached in addEventField, so adding it again here might cause duplicates if not careful.
                         // Using .one() in addEventField for the remove button click might be safer if delegation is complex.
                         // Let's attach the listener here specifically for newly added buttons during renumbering
                         $(this).find('.remove-button').on('click', function() {
                             $(this).closest('.event-card').remove();
                             eventCount--;
                             updateEventNumbers();
                              validateAllConditionalFields();
                         });
                   }
              }

               $(this).attr('data-event-number', newEventNumber); // Update data attribute
          });
           // Manage "Add Event" button visibility after renumbering
         if (eventCount < MAX_EVENTS) {
             $('#addEventBtn').show();
         }
          console.log("Event numbers and IDs updated.");
           // Ensure max date attribute is correct after renumbering (it should already be set in addEventField)
            $('input[type="datetime-local"]').attr('max', getCurrentDateTimeLocal());
     }


    // --- Function to fetch and populate dropdowns from Google Sheet via Proxy ---
    async function fetchAndPopulateDropdown(dropdownId, sheetName, columnName) {
        console.log(`Attempting to fetch and populate dropdown #${dropdownId} from sheet "${sheetName}" column "${columnName}"`);
        const dropdown = document.getElementById(dropdownId);
        if (!dropdown) {
            console.error(`Dropdown element #${dropdownId} not found.`);
            return;
        }

        // Clear existing options before populating
        $(dropdown).empty();
        // Add a default blank option for required fields with select2 allowClear
        $(dropdown).append('<option value=""></option>');


        try {
            // NOTE: You need a server-side proxy (like a Netlify Function or similar)
            // to forward requests from your frontend to the Google Apps Script Web App URL.
            // The URL '/.netlify/functions/proxy' assumes such a setup.
            // If deploying the HTML directly from Google Drive or similar, you would
            // fetch the Google Apps Script Web App URL directly.
            // const scriptUrl = 'YOUR_GOOGLE_APPS_SCRIPT_WEB_APP_URL_HERE';
            // const response = await fetch(scriptUrl, { ... });
            const response = await fetch('/.netlify/functions/proxy', { // Using proxy based on your code
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    type: 'getDropdownData',
                    sheet: sheetName,
                    column: columnName
                })
            });

            console.log(`Dropdown data fetch response status for ${sheetName}/${columnName}: ${response.status}`);

             // Always attempt to read response body as text to get potential error details
             const responseText = await response.text();
             console.log(`Dropdown data fetch raw response body for ${sheetName}/${columnName}: ${responseText}`);


            if (!response.ok) {
                 const errorMsg = `HTTP error fetching dropdown data for ${sheetName}/${columnName}: Status ${response.status}, Body: ${responseText}`;
                 console.error(errorMsg);
                 // Attempt to parse text as JSON to get potential server error message
                 try {
                     const errorJson = JSON.parse(responseText);
                     if (errorJson && errorJson.error) {
                          throw new Error(`Failed to fetch data for ${sheetName}/${columnName}: ${errorJson.error}`);
                     } else {
                          // If JSON parsing fails or no specific error property, use the HTTP status/body
                           throw new Error(errorMsg);
                     }
                 } catch (parseError) {
                     console.error("Failed to parse dropdown error response as JSON:", parseError);
                      // If parsing fails, use the HTTP status/body
                      throw new Error(errorMsg);
                 }
            }

             // If response is OK, parse the JSON
             const data = JSON.parse(responseText); // Parse the text after checking response.ok
            console.log(`Data received for #${dropdownId}:`, data);

            if (data && Array.isArray(data.data)) {
                 if (data.data.length === 0) {
                      console.warn(`No data received for dropdown #${dropdownId}. Sheet "${sheetName}", column "${columnName}" might be empty or not found.`);
                 }
                data.data.forEach(item => {
                    // Ensure item is not null, undefined, or empty string before adding
                    if (item !== null && item !== undefined && String(item).trim() !== '') {
                        const option = document.createElement('option');
                        option.value = item;
                        option.textContent = item;
                        dropdown.appendChild(option);
                    }
                });
                console.log(`Options added to #${dropdownId}. Total options (including blank): ${dropdown.options.length}`);
            } else {
                console.error(`Invalid data format received for #${dropdownId}. Expected an object with an array 'data'. Received:`, data);
                throw new Error('Invalid data format received from server for dropdowns.');
            }

        } catch (error) {
            console.error(`Error fetching or populating dropdown data for #${dropdownId}:`, error);
            alert(`Failed to load data for dropdown "${dropdownId}". Please ensure the Google Sheet, sheet names, and column names are correct, and the Apps Script and proxy are configured to handle data requests. Error: ${error.message}`);
        } finally {
             // Ensure Select2 is updated even if fetching failed, to show the placeholder
             if ($(dropdown).hasClass('select2-hidden-accessible')) {
                  // Reset Select2 to the blank option
                  $(dropdown).val(null).trigger('change.select2');
                  console.log(`Select2 triggered for #${dropdownId} after population attempt.`);
             } else {
                  console.warn(`Select2 not initialized on #${dropdownId}. Cannot trigger change.select2`);
             }
        }
    }


    // --- Function to Initialize the Form Features (Comprehensive Validation) ---
    // This function is called AFTER successful login
    function initializeForm() {
        console.log("Initializing form features...");

        // Initialize Select2 on all relevant dropdowns
        $('#operatorName, #selectOption, #siteAttend, #siteDropdown, #pgOperatorDropdown, #teamLeaderDropdown').each(function() {
             // Check if Select2 is already initialized to prevent re-initialization issues
             if ($(this).data('select2')) {
                  $(this).select2('destroy'); // Destroy if already initialized
             }
             $(this).select2({
                  placeholder: 'Select...',
                  allowClear: true, // Allows clearing the selection if a blank <option> exists
                  dropdownParent: $('#formContainer')[0] // Helps with z-index issues
             });
              console.log(`Select2 initialized on #${this.id}`);
         });
        console.log("Select2 initialization process completed.");


        // Set max date for native datetime-local inputs initially
        const nowFormatted = getCurrentDateTimeLocal();
        $('input[type="datetime-local"]').attr('max', nowFormatted);
        console.log(`Set max date/time for datetime-local inputs to: ${nowFormatted}`);

        // --- IMPORTANT: Populate dropdowns after login ---
        // Use async/await for clarity, though they run independently after this
        fetchAndPopulateDropdown('siteDropdown', 'Sites', 'Site_Code');
        fetchAndPopulateDropdown('pgOperatorDropdown', 'Employees', 'Employee_Code');
        fetchAndPopulateDropdown('teamLeaderDropdown', 'Employees', 'Employee_Code');
        console.log("Dropdown data population process initiated after form initialization.");


        // --- Event Listeners ---

        // Basic required fields validation on blur (for text inputs)
        $('#ttNumber').on('blur', function() {
            console.log("TT Number blur event fired.");
            // Only validate if the parent card/section is visible
            if ($(this).closest('.card').is(':visible')) {
               validateField('ttNumber');
            } else {
                 displayError('ttNumber', ''); // Clear error if field is hidden
            }
         });

         // Select2 fields validation on change and handling conditional sections
         $('#operatorName, #siteDropdown, #pgOperatorDropdown, #teamLeaderDropdown, #selectOption, #siteAttend').on('change', function() {
              const fieldId = $(this).attr('id');
               console.log(`Change event fired on #${fieldId}. Value: ${$(this).val()}`);

              // Handle conditional section display and clearing fields/errors
              if (fieldId === 'selectOption') {
                   console.log("selectOption changed. Handling conditional section display.");
                    if ($(this).val() === 'Misscall TT') {
                        $('#misscallTTFields').show();
                        $('#pgRunFields').hide();
                         // Clear PG Run fields and errors when hiding
                         $('#pgEventsContainer').empty(); // Remove all dynamic event cards
                         eventCount = 0; // Reset event counter
                         $('#addEventBtn').hide(); // Hide add button
                         // Clear errors for removed PG fields (validateAllConditionalFields handles clearing visible errors)

                    } else if ($(this).val() === 'PG Run') {
                        $('#misscallTTFields').hide();
                        $('#pgRunFields').show();
                         // Clear Misscall TT fields and errors when hiding
                         // Use .val(null).trigger('change.select2') for Select2 fields
                         $('select', '#misscallTTFields').val(null).trigger('change.select2');
                         $('input[type="datetime-local"]', '#misscallTTFields').val('');
                         $('#siteAttendDateTimeField').hide(); // Hide the DateTime field for Misscall TT if YES was selected
                         // Add the initial 1st event field if PG Run is selected and none exist
                         if (eventCount === 0) {
                             addEventField(1);
                         }
                         // Manage visibility of add button based on initial state
                         if (eventCount < MAX_EVENTS) {
                             $('#addEventBtn').show();
                         } else {
                             $('#addEventBtn').hide();
                         }

                    } else { // If no option is selected (e.g., back to placeholder)
                        $('#misscallTTFields').hide();
                        $('#pgRunFields').hide();
                         // Clear all conditional fields and errors
                         $('select', '#misscallTTFields').val(null).trigger('change.select2');
                         $('input[type="datetime-local"]', '#misscallTTFields').val('');
                         $('#siteAttendDateTimeField').hide();
                         $('#pgEventsContainer').empty(); // Remove all dynamic event cards
                         eventCount = 0; // Reset counter
                         $('#addEventBtn').hide(); // Hide add button
                    }
              } else if (fieldId === 'siteAttend') {
                   if ($(this).val() === 'YES') {
                       $('#siteAttendDateTimeField').show();
                        const nowFormatted = getCurrentDateTimeLocal();
                       $('#siteAttendDateTime').attr('max', nowFormatted); // Set max date/time for site attend DT
                   } else {
                       $('#siteAttendDateTimeField').hide();
                       $('#siteAttendDateTime').val(''); // Clear the value when hiding
                       displayError('siteAttendDateTime', ''); // Clear any errors for this field
                   }
              }

             // Trigger validation after visibility changes and field clearing
              // Only validate standard field if its container is visible
             if ($(this).closest('.card').is(':visible')) {
                 validateField(fieldId);
             } else {
                  displayError(fieldId, ''); // Clear error if hidden
             }
             // Always re-validate all conditional fields after changes in selectOption or siteAttend
             validateAllConditionalFields();
         });


         // --- Add Event Button Listener ---
         $('#addEventBtn').on('click', function() {
             // Before adding a new event, validate the LAST event's start and stop times
             const lastEventNumber = eventCount; // eventCount is the number of events currently displayed
             const lastEventCard = $('#pgEventsContainer').find(`.event-card[data-event-number="${lastEventNumber}"]`);

              let lastEventValid = true;

              // Only validate the last event if at least one event exists
              if (lastEventNumber > 0 && lastEventCard.length > 0) {
                   const lastPgStartId = `pgStart${lastEventNumber}`;
                   const lastPgStopId = `pgStop${lastEventNumber}`;
                   const lastPgStartVal = $(`#${lastPgStartId}`).val();
                   const lastPgStopVal = $(`#${lastPgStopId}`).val();

                   // Perform validation for the last event card
                   validateAllConditionalFields(); // This will update errors on the last event and related sequential errors

                   // Check if the last event card has any validation errors after calling validateAllConditionalFields
                   const lastStartErrorText = $(`#${lastPgStartId}-error`).text().trim();
                   const lastStopErrorText = $(`#${lastPgStopId}-error`).text().trim();


                    // If the last event is completely empty and it's NOT the first event,
                    // allow adding a new one (it's an optional skipped event).
                    // If the last event is the first one (eventNumber 1) and is empty, validateAllConditionalFields
                    // will add specific mandatory errors.
                   if (!lastPgStartVal && !lastPgStopVal && lastEventNumber > 1) {
                        // Last event is empty and optional, allow adding.
                        lastEventValid = true;
                   } else if (lastStartErrorText || lastStopErrorText) {
                        // If there are ANY validation errors on the last event (including mandatory, sequential, format etc.)
                         alert("Please fix the errors in the current (last) event before adding a new one.");
                         lastEventValid = false; // Prevent adding
                   } else {
                       // If the last event is fully or partially filled AND has no validation errors, it's valid enough to proceed.
                       lastEventValid = true;
                   }

              } else {
                 // If no event cards exist yet (eventCount is 0), allow adding the first one.
                  lastEventValid = true;
              }


             // Only add the new event if the last event was valid (or no events existed yet) AND we are under the limit
             if (lastEventValid && eventCount < MAX_EVENTS) {
                 addEventField(eventCount + 1);
                 // Scroll to the newly added event (optional)
                  $('html, body').animate({
                     scrollTop: $(`[data-event-number="${eventCount}"]`).offset().top - 100 // Adjust offset as needed
                  }, 500);
             } else if (eventCount >= MAX_EVENTS) {
                 alert(`You can add a maximum of ${MAX_EVENTS} events.`);
             }
         });


       // --- Form Submission Handler ---
       $('#pgForm').submit(function (event) {
         event.preventDefault();
          console.log("Form submission started.");

          // Perform full client-side validation on all relevant fields before submitting
          let formIsValid = true;
          console.log("Running pre-submit validation...");

           // Validate mandatory fields that are currently visible
            // TT Number is mandatory if the card is visible
            if ($('#ttNumber').closest('.card').is(':visible')) {
                 console.log("Validating TT Number.");
                if (!validateField('ttNumber')) formIsValid = false;
            } else {
                 displayError('ttNumber', ''); // Clear error if TT Number is hidden
            }

            // Operator Name, Site, PG Operator, Team Leader are generally mandatory if their cards are visible
            if ($('#operatorName').closest('.card').is(':visible')) {
                 console.log("Validating Operator Name.");
                if (!validateField('operatorName')) formIsValid = false;
            } else { displayError('operatorName', ''); }
            if ($('#siteDropdown').closest('.card').is(':visible')) {
                 console.log("Validating Site.");
                if (!validateField('siteDropdown')) formIsValid = false;
            } else { displayError('siteDropdown', ''); }
            if ($('#pgOperatorDropdown').closest('.card').is(':visible')) {
                 console.log("Validating PG Operator.");
                if (!validateField('pgOperatorDropdown')) formIsValid = false;
            } else { displayError('pgOperatorDropdown', ''); }
            if ($('#teamLeaderDropdown').closest('.card').is(':visible')) {
                 console.log("Validating Team Leader.");
                if (!validateField('teamLeaderDropdown')) formIsValid = false;
            } else { displayError('teamLeaderDropdown', ''); }
            if ($('#selectOption').closest('.card').is(':visible')) {
                 console.log("Validating Select Option.");
                if (!validateField('selectOption')) formIsValid = false;
            } else { displayError('selectOption', ''); }


          // Validate conditional fields (including PG events and Site Attend Date/Time)
           console.log("Running final conditional date/time validation before submit.");
          formIsValid = validateAllConditionalFields() && formIsValid;
           console.log("Overall form validation result:", formIsValid);


          if (!formIsValid) {
             $('.loading').hide();
             alert('Please fix the errors in the form before submitting.');
             console.log("Form validation failed before submit.");
             return; // Stop submission
          }
          console.log("Form validation passed. Preparing data for submission.");


          // Collect data dynamically, especially PG Run events
          const jsonData = {};

          // Collect standard fields
          jsonData['ttNumber'] = $('#ttNumber').val() || '';
          jsonData['operatorName'] = $('#operatorName').val() || '';
          jsonData['site'] = $('#siteDropdown').val() || '';
          jsonData['pgOperator'] = $('#pgOperatorDropdown').val() || '';
          jsonData['teamLeader'] = $('#teamLeaderDropdown').val() || '';
          jsonData['selectOption'] = $('#selectOption').val() || '';
          jsonData['siteAttend'] = $('#siteAttend').val() || '';
           // Send the raw value from the datetime-local input for Site Attend DateTime
          jsonData['siteAttendDateTime'] = $('#siteAttendDateTime').val() || '';


           // Include the logged-in username in the submission data
           jsonData['entryBy'] = loggedInUsername;
           console.log("Adding EntryBy to submission data:", loggedInUsername);

           // Collect PG Run events dynamically
           if (jsonData['selectOption'] === 'PG Run') {
               jsonData.pgEvents = []; // Initialize an array to hold PG events
                $('#pgEventsContainer').children('.event-card').each(function() {
                    const eventNumber = $(this).data('event-number'); // Get the event number from data attribute
                     // Get the raw values from the datetime-local inputs
                    const pgStartVal = $(`#pgStart${eventNumber}`).val();
                    const pgStopVal = $(`#pgStop${eventNumber}`).val();

                    // Only include the event in the submitted data if both start and stop times are filled
                    // Server-side will perform definitive validation and overlap checks
                    if (pgStartVal && pgStopVal) {
                        jsonData.pgEvents.push({
                            eventNumber: eventNumber,
                            start: pgStartVal, // Send raw YYYY-MM-DDTHH:MM string
                            stop: pgStopVal    // Send raw YYYY-MM-DDTHH:MM string
                        });
                    }
                });
               console.log("Collected PG Events:", jsonData.pgEvents);
                // Server-side validation will handle the case where PG Run is selected but no valid events are collected.
                // However, client-side validation already checks that at least one event is fully filled.
           }


         jsonData.timestamp = new Date().toISOString(); // Add timestamp

         console.log("Data being sent:", JSON.stringify(jsonData, null, 2));

         $('.loading').show(); // Show loading message

         // Send form data to Google Apps Script via proxy
         // Ensure your proxy is correctly configured to forward POST requests to your Apps Script Web App URL
         // If not using a proxy, replace '/.netlify/functions/proxy' with your script's Web App URL.
         fetch('/.netlify/functions/proxy', {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify(jsonData) // Send the collected JSON data
         })
         .then(response => {
             console.log("Form Fetch Response Status:", response.status);
             console.log("Form Fetch Response OK:", response.ok);

             // Always attempt to read the response body as text, even on non-OK statuses,
             // as the server sends error details in the body.
             return response.text().then(text => {
                  console.log("Form Fetch Raw Response Text:", text);
                  // Return an object containing both the response status and the parsed body/text
                  let parsedData = null;
                  try {
                       if (text && text.trim() !== '') {
                           parsedData = JSON.parse(text);
                       }
                  } catch(e) {
                       console.warn("Failed to parse response text as JSON:", e);
                       // If parsing fails, treat it as plain text error or leave null
                  }
                  return {
                       ok: response.ok,
                       status: response.status,
                       data: parsedData,
                       rawText: text
                  };
             });
         })
        .then(({ ok, status, data, rawText }) => { // Destructure the returned object
           $('.loading').hide(); // Hide loading message
           console.log("Form Response Processed Data:", data);

           if (ok && data && typeof data === 'object' && data.result === 'success') {
               $('.success-message').show();
               $('#pgForm')[0].reset(); // Reset the form fields

                // Reset Select2 dropdowns and trigger change
               $('#operatorName, #selectOption, #siteAttend').val(null).trigger('change.select2');
               $('#siteDropdown, #pgOperatorDropdown, #teamLeaderDropdown').val(null).trigger('change.select2');
                $('.select2-selection__rendered').empty().append('<span class="select2-selection__placeholder">Select...</span>');

                // Clear native datetime-local inputs
                 $('input[type="datetime-local"]').val('');

               // Clear and reset dynamic PG Run fields
               $('#pgEventsContainer').empty(); // Remove all dynamic cards
               eventCount = 0; // Reset counter
               $('#addEventBtn').hide(); // Hide the add button initially


               // Clear all validation errors and invalid classes
               $('.error-message').text('');
               $('input, select').removeClass('is-invalid');
               $('.select2-container .select2-selection--single').removeClass('is-invalid');


               setTimeout(() => { $('.success-message').hide(); }, 3000); // Hide success message after 3 seconds
           } else { // Handle cases where response.ok is false OR success is explicitly false in data
                const errorData = (data && typeof data === 'object' && data.error) ? (typeof data.error === 'object' ? data.error : { message: data.error }) : { message: 'Submission failed due to a server error or unexpected response format.', raw: rawText, status: status }; // Structure error data
                const errorMessage = errorData.message || 'An unknown error occurred.';

                console.error('Submission failed:', errorData);
                $('.success-message').hide(); // Ensure success message is hidden

                // --- Error Highlighting Logic ---
                // Clear all client-side validation errors and invalid classes first for clarity before highlighting server errors
                $('.error-message').text('');
                $('input:not(.select2-search__field), select').removeClass('is-invalid');
                $('.select2-container .select2-selection--single').removeClass('is-invalid');


                if (errorData.field) {
                    // Handle standard field errors (like TT Number duplicate, or missing headers from server)
                     const fieldIdToHighlight = errorData.field; // e.g., "ttNumber" or potentially others from server
                     displayError(fieldIdToHighlight, errorMessage); // Display the server error message next to the field
                     // Scroll to the field (optional but helpful)
                     const fieldElement = $(`#${fieldIdToHighlight}`);
                      if (fieldElement.length) {
                           $('html, body').animate({
                               scrollTop: fieldElement.offset().top - 100 // Adjust offset
                           }, 500);
                      } else {
                           console.warn(`Field element #${fieldIdToHighlight} not found for highlighting.`);
                            // If field element not found for highlighting, show a general alert
                           alert('Submission failed: ' + errorMessage);
                      }
                } else if (errorData.conflictingEventNumber) {
                    // Handle PG Run overlap errors
                    const conflictingEventNumber = errorData.conflictingEventNumber;
                    const conflictCard = $(`#pgEventsContainer`).find(`.event-card[data-event-number="${conflictingEventNumber}"]`);

                    if (conflictCard.length) {
                        // Highlight the specific start and stop inputs in the conflicting card
                        const startInputId = conflictCard.find('input[type="datetime-local"][name^="pgStart"]').attr('id');
                        const stopInputId = conflictCard.find('input[type="datetime-local"][name^="pgStop"]').attr('id');


                        // Use a generic conflict message or the specific server message
                        const conflictMessage = `Event ${conflictingEventNumber}: ` + errorMessage;

                        if (startInputId) displayError(startInputId, conflictMessage);
                        if (stopInputId) displayError(stopInputId, conflictMessage);


                        // Scroll to the conflicting event card
                        $('html, body').animate({
                           scrollTop: conflictCard.offset().top - 100 // Adjust offset as needed
                        }, 500);

                    } else {
                        console.warn(`Conflicting event card with number ${conflictingEventNumber} not found on the page.`);
                        // If the specific event card isn't found, maybe highlight the PG Run section or the site dropdown?
                        // For now, just log and rely on the general alert.
                         alert('Submission failed: ' + errorMessage);
                    }
                } else {
                    // Handle other types of server-side errors without specific field/event info
                    // This includes the "Server busy" message returned by LockService
                     alert('Submission failed: ' + errorMessage); // Show general error message in an alert
                     console.error('Server returned a non-field-specific error:', errorData);
                     // Could display this error in a general form message area if available
                }
                // --- End Error Highlighting Logic ---
             }
         })
         .catch(error => {
           // This catches network errors or issues with the fetch operation itself
           $('.loading').hide();
           alert('Submission failed (Network Error): ' + error.message);
           console.error('Fetch Error:', error);
         });
       });
        console.log("Form submission handler set up.");


    } // End of initializeForm function


    // --- Login Page JavaScript ---

    // Helper function to display or clear error messages for the login form
    function displayLoginError(fieldId, message) {
        const errorSpan = $(`#${fieldId}-error`); // Target the specific error span for the login input
        const fieldElement = $(`#${fieldId}`); // The login input element (username or password)
         const loginStatusDiv = $('#login-status'); // The general login message div

         // Handle general login status messages (#login-status) first
         if (fieldId === 'login-status') {
             loginStatusDiv.text(message);
             if (message) {
                 // Apply 'error' or 'success' class based on the message content
                  if (message.includes('Invalid') || message.includes('failed') || message.includes('Error') || message.includes('busy')) { // Added 'busy' to error class trigger
                       loginStatusDiv.addClass('error').removeClass('success');
                  } else {
                       loginStatusDiv.addClass('success').removeClass('error');
                  }
                  loginStatusDiv.show(); // Show the message div
             } else {
                  loginStatusDiv.text('').removeClass('success error').hide(); // Hide and clear
             }
              // Don't proceed to field-specific handling if this was a status update
             return;
         }


         // If not a status update, ensure fieldElement exists for input-specific handling
         if (!fieldElement.length) {
              console.error(`Login field element #${fieldId} not found.`);
             if (errorSpan.length) errorSpan.text('');
             return;
         }


        // Handle input specific errors (username-error, password-error)
        if (errorSpan.length) {
            if (message) {
                errorSpan.text(message);
                fieldElement.addClass('is-invalid'); // Use is-invalid class for login inputs
            } else {
                errorSpan.text('');
                fieldElement.removeClass('is-invalid');
            }
        } else {
             // Fallback: If no error span but message exists, just apply the invalid class
             if (message) {
                 fieldElement.addClass('is-invalid');
                  console.warn(`Error span not found for login field: #${fieldId}-error. Cannot display text error.`);
             } else {
                  fieldElement.removeClass('is-invalid');
             }
        }
    }


    // Handle login form submission
    $('#loginForm').submit(function(event) {
      event.preventDefault(); // Prevent default form submission
       console.log("Login form submitted."); // Log login form submission

      // Clear previous errors and status messages
      displayLoginError('username', ''); // Clear username error
      displayLoginError('password', ''); // Clear password error
      displayLoginError('login-status', ''); // Clear general status message

      const username = $('#username').val().trim(); // Get and trim username input
      const password = $('#password').val().trim(); // Get and trim password input
      let formIsValid = true; // Basic client-side check for login form

      // Basic validation for empty fields
      if (!username) {
        displayLoginError('username', 'Username is required.');
        formIsValid = false;
      }
      if (!password) {
        displayLoginError('password', 'Password is required.');
        formIsValid = false;
      }

      // If basic client-side validation fails, stop here
      if (!formIsValid) {
         displayLoginError('login-status', 'Please enter username and password.');
         console.log("Login form validation failed client-side.");
        return;
      }

      // Show a loading indicator using the login status div
       displayLoginError('login-status', 'Logging in...'); // Use the status div for loading message
       console.log("Attempting to fetch login endpoint."); // Log fetch attempt

      // Send login request to Google Apps Script via proxy
      // Ensure your proxy is configured to forward POST requests to your Apps Script Web App URL.
      // If not using a proxy, replace '/.netlify/functions/proxy' with your script's Web App URL.
      fetch('/.netlify/functions/proxy', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ login: true, username: username, password: password }) // Send login flag and credentials
      })
      .then(response => {
           console.log("Login Fetch received response."); // Log receipt of response
           // Always read the response body, even on non-OK statuses, to get potential error messages
          return response.text().then(text => {
               console.log("Login Fetch Raw Response Text:", text); // Log raw response text
               console.log("Login Fetch Response Status:", response.status); // Log response status
               console.log("Login Fetch Response OK:", response.ok); // Log response OK status
               console.log("Login Fetch Response Headers:", Array.from(response.headers.entries())); // Log response headers

               // Attempt to parse the response text as JSON
               let data = null;
               try {
                   // If the text is not empty or null, try to parse it as JSON
                   if (text && text.trim() !== '') {
                       data = JSON.parse(text);
                        console.log("Login Fetch Parsed Data:", data); // Log parsed JSON data
                   } else {
                       // If the text is empty, it might be an empty but successful-status response or an error with no body
                       console.error("Received empty or null response body for login.");
                       // If the status is OK but the body is empty, throw an error
                       if (response.ok) {
                           throw new Error('Received empty response body from server.');
                       } else { // If status is not OK and body is empty, throw a status error
                           throw new Error(`Server returned status ${response.status} with empty body.`);
                       }
                   }
               } catch (jsonError) {
                   // If JSON parsing fails, log the error and the response text
                   console.error('Failed to parse login response as JSON:', jsonError, 'Response text:', text);
                    // If parsing fails and the status was OK, it's an unexpected format issue
                   if (response.ok) {
                        throw new Error('Login failed: Invalid JSON response from server.');
                   } else { // If parsing fails and status was not OK, the status error is more relevant
                        throw new Error(`Server returned status ${response.status} and invalid response format.`);
                   }
               }

               // If the response was not OK (status outside 200-299 range), even if JSON parsed, propagate the error
               if (!response.ok) {
                   // Use the server-provided error message if available in the parsed data, otherwise use a generic message
                   const serverErrorMessage = (data && typeof data === 'object' && data.error) ? (typeof data.error === 'object' ? data.error.message : data.error) : 'Server error occurred.';
                   // Include the status code in the error message
                   throw new Error(`Login failed: Status ${response.status} - ${serverErrorMessage}`);
               }

               // If response is OK and JSON is parsed successfully, return the data
               return data;
          });
      })
      .then(data => {
        console.log("Login Response Data:", data); // Log the final data object
        // Check if data is a valid object and explicitly check if the 'success' property is boolean true
        if (data && typeof data === 'object' && data.success === true) {
          displayLoginError('login-status', 'Login successful!'); // Show success message
          console.log("Login successful, showing form."); // Log successful login

          // Store the logged-in username here
          loggedInUsername = $('#username').val().trim();
          console.log("Stored username:", loggedInUsername);

          $('#loginContainer').hide(); // Hide the login page container
          $('#formContainer').show(); // Show the form page container
           initializeForm(); // Call the function to initialize all form features
        } else {
          // Handle login failure based on the server response (data.success is false or missing)
          const errorMessage = (data && typeof data === 'object' && data.error) ? (typeof data.error === 'object' ? data.error.message : data.error) : 'Invalid username or password.';
          displayLoginError('login-status', errorMessage); // Show the login failure message
           console.log("Login failed:", errorMessage); // Log the failure reason
           $('#password').val(''); // Optionally clear the password field on failure
          $('#username, #password').removeClass('is-invalid'); // Remove invalid classes from login inputs
        }
      })
      .catch(error => {
        console.error('Login Fetch Error:', error); // Log any errors that occurred during the fetch process
        displayLoginError('login-status', 'Login failed: ' + error.message); // Show a user-friendly error message
         $('#username, #password').removeClass('is-invalid'); // Remove invalid classes from login inputs on fetch error
      });
    });

     // Optional: Clear errors on input focus for login fields
      $('#username, #password').on('focus', function() {
          displayLoginError($(this).attr('id'), ''); // Clear specific input error on focus
          displayLoginError('login-status', ''); // Clear general status message on focus
      });

    // --- Initial State on document ready ---
    // The login container is shown by default in HTML, form container is hidden.
    // The login form submission handler is attached here.
    // The form initialization is deferred until successful login.
     $('#formContainer').hide();
     $('#loginContainer').show();
      console.log("Initial display state set: login visible, form hidden.");


  }); // End of $(document).ready
</script>

</body>
</html>